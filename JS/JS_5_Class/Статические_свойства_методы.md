# Статические свойства и методы

***Статические свойства и методы наследуются.***
***Но доступны для вызова только от имени самого класса, не экземпляра!!!***

### **Статические методы**

Мы  можем присвоить метод самому классу. Такие методы называются *статическими* `static`

```jsx
class User {
  static staticMethod() {
    console.log(this === User);
  }
}

User.staticMethod(); // true

По сути то же, что присвоить метод напрямую как свойство функции:
class User { }

User.staticMethod = function() {
  console.log(this === User);
};
```

***Значением `this` при вызове `User.staticMethod()` является сам конструктор класса `User` (правило «объект до точки»).***

**Обычно статические методы используются для реализации функций, которые будут принадлежать классу в целом, а не его экземплярам:** 

```jsx
class Article {
  constructor(title, date) {
    this.title = title;
    this.date = date;
  }

  static compare(articleA, articleB) {
    return articleA.date - articleB.date;
  }
}

// использование
let articles = [
  new Article("HTML", new Date(2019, 1, 1)),
  new Article("CSS", new Date(2019, 0, 1)),
  new Article("JavaScript", new Date(2019, 11, 1))
];

articles.sort(Article.compare); // используем метод самого класса

log( articles[0].title ); // CSS
```

**Статические методы недоступны для отдельных объектов (**экземпляров**)**

### **Статические свойства**

**Статические свойства, также как и методы недоступны для отдельных объектов (**экземпляров**)**

```jsx
class Article {
  static publisher = "Илья Кантор";
}

log( Article.publisher ); // Илья Кантор

// Это то же самое, что и прямое присваивание Article
Article.publisher = "Илья Кантор";

const newArt = new Article();
log(t.publisher)   // undefined
```

### Наследование статических свойств и методов

***Статические свойства и методы наследуются.***

***Разница в том, что при наследовании создается две отдельные  ссылки на прототип, для статических свойств и методов и для обычных***

```jsx
class Animal {
    hi() {
        console.oog('Hi')
    }
}
class Rabbit extends Animal {}

Animal.hi() // Hi
Rabbit.hi() // Hi

const rabbit = newRabit()
rabbit.hi() // Error !!!

// для статики
log(Rabbit.__proto__ === Animal); // true

// для обычных методов
log(Rabbit.prototype.__proto__ === Animal.prototype); // true
```

Итого:

- Статические методы используются для функциональности, принадлежат классу «в целом», а не относятся к конкретному объекту класса.
- В объявлении класса они помечаются ключевым словом `static`.
- Статические свойства используются в тех случаях, когда мы хотели бы сохранить данные на уровне класса, а не какого-то одного объекта.
- Статические свойства и методы наследуются, но доступны для вызова только от имени самого класса, не экземпляра.  С созданием двух разных ссылок на прототип родителя для статики и обычных свойств и методов.
