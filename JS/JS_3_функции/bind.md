# bind - Привязка контекста к функции

## Потеря “this” - передача метода отдельно от объекта

```jsx
let user = {
  firstName: "Вася",
  sayHi() {
    console.log(`Привет, ${this.firstName}!`);
  }
};

setTimeout(user.sayHi, 1000); // Привет, undefined!

аналогичная запись
let f = user.sayHi;
setTimeout(f, 1000); // контекст user потеряли
```

Метод `setTimeout` в браузере имеет особенность: он устанавливает `this=window` для вызова функции. Таким образом, для `this.firstName` он пытается получить `window.firstName`, которого не существует. В других подобных случаях `this` обычно просто становится `undefined`.

### Решение 1: сделать функцию обертку

```jsx
let user = {
  firstName: "Вася",
  sayHi() {
    alert(`Привет, ${this.firstName}!`);
  }
};

setTimeout(function() {
  user.sayHi(); // Привет, Вася!
}, 1000);
Теперь код работает корректно, так как объект user достаётся из замыкания,
а затем вызывается его метод sayHi.

Или можно так 
setTimeout(() => user.sayHi(), 1000); // Привет, Вася!
```

В таком подходе есть уязвимость - если до момента срабатывания `setTimeout`  в переменную `user` будет записано другое значение? Тогда вызов неожиданно будет совсем не тот!

```jsx
let user = {
  firstName: "Вася",
  sayHi() {
    alert(`Привет, ${this.firstName}!`);
  }
};

setTimeout(() => user.sayHi(), 1000);
// ...в течение 1 секунды
user = { sayHi() { alert("Другой пользователь в 'setTimeout'!"); } };
// Другой пользователь в 'setTimeout'!
```

### Решение 2: привязать контекст с помощью bind

```jsx
// частичный синтаксис
let boundFunc = func.bind(context);
Все аргументы передаются исходному методу func как есть.

// полный синтаксис
let bound = func.bind(context, [arg1], [arg2], ...);
```

```jsx
let user = {
  firstName: "Вася",
  say(phrase) {
    alert(`${phrase}, ${this.firstName}!`);
  }
};

let say = user.say.bind(user);

say("Привет"); // Привет, Вася (аргумент "Привет" передан в функцию "say")
say("Пока"); // Пока, Вася (аргумент "Пока" передан в функцию "say")
```

Способ “забиндить” несколько методов одного объекта сразу “bindAll”

```jsx
for (let key in user) {
  if (typeof user[key] == 'function') {
    user[key] = user[key].bind(user);
  }
}
```

### Частичное применение - bind + args

Мы можем привязать не только `this`, но и аргументы. Как все, так и частично.. (Мы создаём новую функцию, фиксируя некоторые из существующих параметров.)

```jsx
function mul(a, b) {
  return a * b;
}

let double = mul.bind(null, 2);

alert( double(3) ); // = mul(2, 3) = 6
alert( double(4) ); // = mul(2, 4) = 8
alert( double(5) ); // = mul(2, 5) = 10
```

### Итого:

- Метод `bind` возвращает «привязанный вариант» функции `func`, фиксируя контекст `this` и первые аргументы `arg1`, `arg2`…, если они заданы.
- Обычно `bind` применяется для фиксации `this` в методе объекта, чтобы передать его в качестве колбэка. Например, для `setTimeout`.
- Когда мы привязываем аргументы, такая функция называется «частично применённой» или «частичной».
- Частичное применение удобно, когда мы не хотим повторять один и тот же аргумент много раз. Например, если у нас есть функция `send(from, to)` и `from` всё время будет одинаков для нашей задачи, то мы можем создать частично применённую функцию и дальше работать с ней.