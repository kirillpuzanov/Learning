# Принципы ООП

- Абстракция
- Инкапсуляция
- Наследование
- Полиморфизм

- ***Абстракция это  процесс выделения общих характеристик и функциональности объектов или системы, игнорируя детали реализации.
Абстракция это описание сразу на уровне базового класса общих (абстрактных) свойств и методов , которые будут нужны всем последующим потомкам, экземплярам этого класса.
Абстрактный метод - как правило метод, который требует дополнения или переопределения…***

- ***Инкапсуляция  это скрытие внутренней реализации объекта от внешнего мира. 
Реализация “внутреннего и внешнего интерфейса” взаимодействия с объектом.***

```jsx
***Абстракция реализована за счет описания обязательных полей для всех фильмов 
независимо от "жанра, страны производства и т.д." 

Инкапсуляция реализована за счет приватных свойств и получение к ним доступа
через свойства аксессоры.***

class Film {
  #name;
  #author;
  #length;
  _rating = 0; // защищенное "публичное свойство" / уствновка с проверкой
  
  constructor(name, author, length) {
    this.#name = name;
    this.#author = author;
    this.#length = length;
  }

  get name() {
    return this.#name;
  }

  get author() {
    return this.#author;
  }

  get length() {
    return this.#length;
  }

 get rating() {
    return this._rating;
  }
  
  set rating(value) { // добавляем проверки при установке 
    if(value > 0 && value < 11) {
      this._rating = value
    } else {
      console.log('Некорректное значение')
    }
  }
}
const film = new Film('test', 'noName', 120);
film.rating = 10;
console.log(film.rating); // 10
```

***-Наследование это процесс создания иерархии классов, где один класс (подкласс) наследует свойства и методы другого класса (суперкласса). Это позволяет сокращать дублирование кода, упрощать структуру программы и создавать более логичные иерархии объектов.***

```
class Book {
  constructor(title, author) {
    this.author = author;
    this.title = title;
  }

  buy(){
    console.log('Buy')
  }
}

class AudioBook extends Book {
  constructor(title, author, minLen) { // обяз. вызов родительского конструктора
    super(title, author);
    this.minLen = minLen;
  }

  log() {
    console.log(`${this.title} - ${this.minLen}`);
  }
}

const book = new AudioBook('Js', 'noName', '120')
book.buy() // Buy
book.log() // Js - 120
```

***-Полиморфизм (многообразие) - разные сущности выполняют одни и те же действия..
 это концепция, при которой разные объекты могут реагировать на один и тот же запрос, проявляя разное поведение в зависимости от своего типа.***

***Суть - создание базового “абстрактного” класса (класс-шаблон), в котором описаны методы одинаковые для всех, но которые будут по разному отрабатывать в зависимости от (будут давать разный результат) в зависимости от входящих параметров, от их типов***

**Полиморфизм ad hoc:**

возможность по-разному выполнять функцию в зависимости от типа входящих данных.
Разный результат при одинаковом названии. Перегрузка методов (если натянуть на ООП).

```jsx
некоторое проявление ad hoc полиморфизма - код один, 
результат в зависимости от типа входящих данных 
const function fn(a, b) {
	return a + b
}
fn('1', '5') // '15'
fn(1, 5) // 6
```

**Параметрический полиморфизм, истинный (обобщенный полиморфизм):**

Возможность выполнять функцию, независимо от типа входящих аргументов

```jsx
Функция console.log выполнятеся вне зависимости от приходящих аргументов
console.log('1')
console.log({name: 'Vasya'})
```

**Полиморфизм подтипов (по умолчанию): ООП-шный вариант**

Это возможность использовать одни и те же методы , или интерфейсы, для разных сущностей — подтипов.

```jsx
// базовый класс врага
class Enemy {
  health;
  constructor(health) {
    this.health = health;
  }
// метод получения урона 
  receiveDamage(damage) {
    this.health = this.health - damage;
    console.log('--  base method health  -->', this.health);
  }
}

// класс меча (принимает значение урона который будет наносить)
class Sword {
  #damage;
  constructor(damage) {
    this.#damage = damage;
  }
  
**//  Полиморфизм подтипов - метод** strike **принимает любого врага
//  вызывает у него метод receiveDamage (может базовый, может перезаписанный),
//  но по сигнатуре одинаковый
//  и передает в него damage
//  любой класс** anyEnemy **имплементирует интерфейс базового врага**
  strike(anyEnemy) {
    anyEnemy.receiveDamage(this.#damage)
  }
}

// наследуется от базового класса врага
class Ork extends Enemy {
  constructor(health) {
    super(health);
  }
  // перезаписывает абстрактный метод receiveDamage
  receiveDamage(damage) {
    if(Math.random() < 0.5) {
      this.health = this.health - damage;
    }
    console.log('--  Ork health  -->', this.health);
  }
}

// наследуется от базового класса врага, ничего не изменяя
class Troll extends Enemy {

}

const enemyOrk = new Ork(10)
const enemyTroll = new Troll(20)
const sword = new Sword(2)
sword.strike(enemyOrk)
sword.strike(enemyOrk)

sword.strike(enemyTroll)
sword.strike(enemyTroll)
sword.strike(enemyTroll)

```