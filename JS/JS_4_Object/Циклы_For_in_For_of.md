# Циклы For in / For of

## For in

*Для перебора всех свойств объекта используется цикл*

```jsx
for (let key in object) {
console.log(object[key])
  // тело цикла выполняется для каждого свойства объекта
}
```

*Cвойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.
Термин «целочисленное свойство» означает строку, которая может быть преобразована в целое число и обратно без изменений.*

## For of  (*итерируемые* объекты)

Чаще всего используется для перебора массивов и строк.

*Перебираемые* (или *итерируемые*) объекты – это обобщение массивов. Концепция, которая позволяет использовать любой объект в цикле `for..of`.

Конечно же, сами массивы являются перебираемыми объектами. Но есть и много других встроенных перебираемых объектов, например, строки.

***Создание итерируемого объекта:***

```jsx
let range = {
  from: 1,
  to: 5
};
// Мы хотим, чтобы работал for..of:
// for(let num of range) ... num=1,2,3,4,5
```

Чтобы сделать `range` итерируемым (и позволить `for..of` работать с ним), нам нужно добавить в объект метод с именем `Symbol.iterator` (специальный встроенный `Symbol`, созданный как раз для этого).

1. Когда цикл `for..of` запускается, он вызывает этот метод один раз (или выдаёт ошибку, если метод не найден). Этот метод должен вернуть *итератор* – объект с методом `next`.
2. Дальше `for..of` работает *только с этим возвращённым объектом*.
3. Когда `for..of` хочет получить следующее значение, он вызывает метод `next()` этого объекта.
4. Результат вызова `next()` должен иметь вид `{done: Boolean, value: any}`, где `done=true` означает, что цикл завершён, в противном случае `value` содержит очередное значение.

Особенности такого подхода - разделение ответственности.

- У самого `range` нет метода `next()`.
- Вместо этого другой объект, так называемый «итератор», создаётся вызовом `range[Symbol.iterator]()`, и именно его `next()` генерирует значения.

```jsx
let range = {
  from: 1,
  to: 5
};

// 1. вызов for..of сначала вызывает эту функцию
range[Symbol.iterator] = function() {
  // ...она возвращает объект итератора:
  // 2. Далее, for..of работает только с этим итератором,
  // запрашивая у него новые значения
  return {
    current: this.from,
    last: this.to,

    // 3. next() вызывается на каждой итерации цикла for..of
    next() {
      // 4. он должен вернуть значение в виде объекта {done:.., value :...}
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// теперь работает!
for (let num of range) {
  alert(num); // 1, затем 2, 3, 4, 5
}
```

Альтернативная реализация:
Технически мы можем объединить их и использовать сам `range` как итератор, чтобы упростить код.

```jsx
let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  }
};

for (let num of range) {
  alert(num); // 1, затем 2, 3, 4, 5
}
```

Теперь `range[Symbol.iterator]()` возвращает сам объект `range`: у него есть необходимый метод `next()`, и он запоминает текущее состояние итерации в `this.current`. Короче? Да. И иногда такой способ тоже хорош.

Недостаток такого подхода в том, что теперь мы не можем использовать этот объект в двух параллельных циклах `for..of`: у них будет общее текущее состояние итерации, потому что теперь существует лишь один итератор – сам объект.

**Бесконечные итераторы**

Можно сделать бесконечный итератор. Например, `range` будет бесконечным при `range.to = Infinity`.

Метод `next` не имеет ограничений, он может возвращать всё новые и новые значения, это нормально.

Конечно же, цикл `for..of` с таким итерируемым объектом будет бесконечным. Но мы всегда можем прервать его, используя `break`.