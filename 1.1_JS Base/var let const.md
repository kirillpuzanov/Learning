# var / let / const

base - [https://learn.javascript.ru/variables](https://learn.javascript.ru/variables) 

var - [https://learn.javascript.ru/var](https://learn.javascript.ru/var)

## var

- функциональная область видимости ( ограничивается телом функции ).

У let и const блочная ( ограничиваются блоками циклов,  условий, функций … )

- Объявления (инициализация) переменных `var` производится в начале исполнения функции (или скрипта для глобальных переменных). Понятие - Hosting всплытие переменных.
- var и let можно инициализировать без присвоения значения.
- Переменные объявленные через 'var' в глобальной области видимости - становятся свойством глобального объекта Window.

Способ создания “блочной” области видимости для var в основном потоке кода с помощью IIFE

```jsx
(function() {
    var message = "Hello";
    alert(message); // Hello
})();
```

## const

- должна быть явная инициализация при обьявлении.
- значение const нельзя переназначить, переприсвоить, переасайнить (но можно изменять само свойство внутри , если это не примитив)

```
   const person = {
   name: 'Kim'
}
 person = {} // Error
 person.name = 'Dasha'  // Ok!
```

Способы создания IIFE

```jsx
// Способы создания IIFE

(function() {
    alert("Круглые скобки вокруг функции");
  })();
  
  (function() {
    alert("Круглые скобки вокруг всего выражения");
  }());
  
  !function() {
    alert("Выражение начинается с логического оператора НЕ");
  }();
  
  +function() {
    alert("Выражение начинается с унарного плюса");
  }();
```

```jsx
//! если внутри функции инициализируется переменная (не объявленная нигде ранее, то неявно происходит ее обьявление в global scope),
// а если такая переменная объявлалась ранее, то она остается локальной
var x = 0;

function f() {
    var x = y = 1;
    // x - объявляется локально ( и = 1 но console.log покажет значение глобальной x).  y - глобальная, со значениеи 1 (т.к. ранее не обьявлялась)!
}
f();
console.log(x, y); // 0, 1
// значение x взято из глобальной переменной, как и ожидалось
// значение переменной y доступно глобально

// ?  у var нет блочной области видимости + цикл выполняется быстрее чем асинхронная операция =>
// ?      => полсле последней итерации i++ увеличивает конечное значение i на единицу, затем log из setTimeout выводит 5 раз увеличенное значение
for (var i = 0; i < 5; i++) {
    setTimeout(() => {
        console.log(i) // 5,5,5,5,5
    }, i * 500)
}
// ?  пути решения:  использовать let
for (let i = 0; i < 5; i++) {
    setTimeout(() => {
        console.log(i) // 0,1,2,3,4
    }, i * 500)
}
// ? обернуть setTimeout IIFE и при ее вызове передать ей i по итогу  log будет брать актуальное значение на момент итерации цикла из замыкания 
for (var i = 0; i < 5; i++) {
    //* IIFE (Immediately Invoked Function Expression)
    ((m) => {
        setTimeout(() => {
            console.log(m) // 0,1,2,3,4
        }, i * 500)
    })(i)
}
```